<?php
/**
 * @file
 * Code for the Domains feature.
 */

include_once 'dvg_domains.features.inc';
include_once 'dvg_domains.dvg.user_permission.inc';

/**
 * Implements hook_dvg_default_permissions_alter().
 */
function dvg_domains_dvg_default_permissions_alter(&$user_role_permissions, $role_names) {
  // Remove roles we don't do anything with.
  $remove_unnecessary_roles = function ($item) {
    return !in_array($item, array('anonymous user', 'authenticated user', 'administrator'));
  };
  $role_names = array_filter($role_names, $remove_unnecessary_roles);

  // Disable enabled basic create/edit/delete permissions
  // for all roles and enable it on assigned domains only.
  foreach ($user_role_permissions as $module => $permissions) {
    foreach ($permissions as $name => $permission) {
      $parts = explode(' ', $name);

      // Skip permissions unless they pass the checks.
      $skip = TRUE;
      // Only permissions matching the following format are parsed: <> = required, [] = optional.
      // <create|edit|delete> [any|own] <content_type> content
      switch (count($parts)) {
        /** @noinspection PhpMissingBreakStatementInspection */
        case 4:
          if (!in_array($parts[1], array('any', 'own'))) {
            break;
          }
          else {
            $domain_part = $parts[1];
            unset($parts[1]);
            // Reset array keys.
            $parts = array_values($parts);
          }
        // Intentional fall-through.
        case 3:
          if (
            in_array($parts[0], array('create', 'edit', 'delete')) &&
            $parts[2] == 'content'
          ) {
            $skip = FALSE;
          }
          break;
      }

      if ($skip) {
        continue;
      }

      $op = ($parts[0] == 'edit') ? 'update' : $parts[0];

      // Grant the node type and operation specific permission.
      $type = $parts[1];

      // Skip these content types.
      if (!in_array($type, variable_get('dvg_domains_type_blacklist', array('domain')))) {
        foreach ($role_names as $rid => $role_name) {
          // We don't support the 'own' permission on Domains.
          if (isset($domain_part) && $domain_part == 'own') {
            unset($user_role_permissions[$module][$name]['roles'][$role_name]);
            unset($domain_part);
            continue;
          }

          // Set or unset the Domain and default node permissions.
          if (isset($user_role_permissions[$module][$name]['roles'][$role_name])) {
            unset($user_role_permissions[$module][$name]['roles'][$role_name]);
            $domain_permission = "$op $type content on assigned domains";
            $user_role_permissions['domain'][$domain_permission]['roles'][$role_name] = $role_name;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_user_default_permissions_alter().
 */
function dvg_domains_user_default_permissions_alter(&$permissions) {
  foreach ($permissions as $name => $permission) {
    $matches = array();
    if (preg_match('/^(create|edit|delete) (.*?) content/', $name, $matches)) {
      $op = ($matches[1] == 'edit') ? 'update' : $matches[1];
      $type_info = explode(' ', $matches[2], 2);
      $roles = array_values(user_roles(FALSE, 'clone node'));

      foreach ($roles as $role_name) {
        $role = user_role_load_by_name($role_name);

        // We don't support the 'own' permission on Domains.
        if (count($type_info) == 2 && $type_info[0] == 'own') {
          unset($permissions[$name]['roles'][$role_name]);
          continue;
        }

        // Grant the node type and operation specific permission.
        $type = end($type_info);

        // Skip these content types.
        if (in_array($type, variable_get('dvg_domains_type_blacklist', array('domain')))) {
          continue;
        }

        // Set or unset the Domain and default node permissions.
        if (isset($permissions[$name]['roles'][$role_name])) {
          user_role_grant_permissions($role->rid, array("$op $type content on assigned domains"));
          unset($permissions[$name]['roles'][$role_name]);
        }
        else {
          user_role_revoke_permissions($role->rid, array("$op $type content on assigned domains"));
        }
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function dvg_domains_form_features_export_form_alter(&$form, &$form_state) {
  drupal_set_message(t('Exporting node permissions may fail because the DVG Domains feature overrides them.'), 'warning');
}

/**
 * Implements hook_preprocess_HOOK().
 */
function dvg_domains_preprocess_views_view_table(&$variables, $hook) {
  if ($variables['view']->name == 'dvg_administration_files' && !empty($variables['result'][0]->field_dvg_domain_file)) {
    $domain = domain_get_domain();
    $domain_id = $domain['domain_id'];
    $count_disabled_vbo_rows = 0;
    foreach ($variables['rows'] as $row_id => &$row) {
      $file_domain_id = -1;
      if (isset($variables['result'][$row_id]->field_dvg_domain_file[0]['raw']['domain_id'])) {
        $file_domain_id = $variables['result'][$row_id]->field_dvg_domain_file[0]['raw']['domain_id'];
      }

      if ($file_domain_id != $domain_id) {
        // Disable VBO and edit-links.
        $count_disabled_vbo_rows++;
        $row['views_bulk_operations'] = $row['edit'] = '';
        // Remove link from filename.
        $row['filename'] = check_plain($variables['result'][$row_id]->file_managed_filename);
      }
    }

    if ($count_disabled_vbo_rows == count($variables['rows'])) {
      $variables['header']['views_bulk_operations'] = '';
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function dvg_domains_form_views_exposed_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  if ($form_state['view']->name == 'dvg_administration_files' && !empty($form['domain_id']['#options'])) {
    $options = array(
      DOMAIN_ALL => t('All domains'),
      '***CURRENT_DOMAIN***' => t('Current Domain'),
    );
    $accessible_domain_ids = domain_get_user_domains($user);
    foreach (domain_domains() as $domain) {
      if (in_array($domain['domain_id'], $accessible_domain_ids)) {
        $options[$domain['domain_id']] = check_plain($domain['sitename']);
      }
    }
    $form['domain_id']['#options'] = $options;
  }
}

/**
 * Implements hook_views_query_alter().
 */
function dvg_domains_views_query_alter(&$view, &$query) {
  switch ($view->name) {
    case 'dvg_administration_nodes':
      $query->options['disable_sql_rewrite'] = 1;
      break;
  }
}

/**
 * Implements hook_views_pre_view().
 */
function dvg_domains_views_pre_view(View &$view, &$display_id, &$args) {
  global $conf;
  switch ($view->name) {
    case 'dvg_administration_files':

      $domain = domain_get_domain();
      if ($domain['is_default']) {
        // Temporary disable domain entity access rules for the default domain.
        $conf['domain_entity_bypass_access_conditions'] = 1;

        // Add domain name to the fields.
        $view->add_item($view->current_display, 'field', 'field_data_domain_file', 'domain_file', array(
          'label' => 'Published on',
          'display_method' => 'sitename',
          'type' => 'domain_entity_sitename',
        ), 'dvg_domain_file');

        // Add domain name as exposed filter.
        $view->add_item($view->current_display, 'filter', 'field_data_domain_file', 'domain_file_domain_id', array(
          'exposed' => TRUE,
          'value' => array('***CURRENT_DOMAIN***' => '***CURRENT_DOMAIN***'),
          'expose' => array(
            'label' => 'Published on',
            'identifier' => 'domain_id',
            'operator_id' => 'domain_file_domain_id_op',
            'operator' => 'domain_file_domain_id_op',
          ),
        ), 'dvg_domain_file_domain_id');
      }

      break;

    case 'dvg_administration_nodes':

      // Add domain name to the fields.
      $view->add_item($view->current_display, 'field', 'domain_access', 'gids', array(
        'label' => 'Published on',
        'display_method' => 'sitename',
        'all_domain_show' => 'text',
        'all_domain_text' => 'All domains',
      ), 'dvg_domain_field');

      // Add a clone link to the fields.
      $view->add_item($view->current_display, 'field', 'node', 'clone_node', array(
        'label' => 'Clone',
      ), 'clone_node');

      // Add the clone link to the 'edit_node' column.
      $style_options = $view->display[$view->current_display]->handler->get_option('style_options');
      $style_options['columns']['clone_node'] = 'edit_node';
      $view->display[$view->current_display]->handler->set_option('style_options', $style_options);

      // Add domain name as exposed filter.
      $view->add_item($view->current_display, 'filter', 'domain_access', 'gid', array(
        'exposed' => TRUE,
        'value' => array('***CURRENT_DOMAIN***' => '***CURRENT_DOMAIN***'),
        'expose' => array(
          'label' => 'Published on',
          'identifier' => 'domain_id',
        ),
      ), 'dvg_domain_filter');

      break;

    case 'dvg_administration_users':

      // Add associated domain name to the fields.
      $view->add_item($view->current_display, 'field', 'domain_editor', 'domain_ids', array(
        'label' => 'Assigned domains',
        'display_method' => 'sitename',
      ), 'dvg_domain_field');

      // Add domain name as exposed filter.
      $view->add_item($view->current_display, 'filter', 'domain_editor', 'domain_id', array(
        'exposed' => TRUE,
        'value' => array('***CURRENT_DOMAIN***' => '***CURRENT_DOMAIN***'),
        'expose' => array(
          'label' => 'Assigned to',
          'identifier' => 'domain_id',
        ),
      ), 'dvg_domain_filter');

      break;
  }
}

/**
 * Implements hook_admin_menu_cache_cid_alter().
 */
function dvg_domains_admin_menu_cache_cid_alter(&$cid) {
  $domain = domain_get_domain();
  $cid .= ':' . $domain['domain_id'];
}

/**
 * Implements hook_menu_alter().
 */
function dvg_domains_menu_alter(&$items) {
  // Fix the node clone menu type.
  $items['node/%node/clone/%clone_token']['type'] = MENU_LOCAL_TASK;
}

/**
 * Implements hook_module_implements_alter().
 */
function dvg_domains_module_implements_alter(&$implementations, $hook) {
  _dvg_global_module_implements_first('dvg_domains', array('node_access'), $implementations, $hook);
  _dvg_global_module_implements_last('dvg_domains', array('menu_alter'), $implementations, $hook);
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Hides the domains vertical tab and sets default values.
 */
function dvg_domains_form_node_form_alter(&$form, &$form_state) {
  $form['domain']['domain_site']['#value'] = 0;
  if (!user_access('administer nodes')) {
    $form['domain']['#access'] = FALSE;
  }
  else {
    $form['domain']['domain_site']['#access'] = FALSE;
    $form['domain']['domains']['#type'] = 'radios';
    $form['domain']['domains']['#default_value'] = reset($form['domain']['domains']['#default_value']);
  }
}

/**
 * Implements hook_node_access().
 *
 * - Allow cross-domain node views for editors.
 * - Disallow cross-domain update and delete.
 */
function dvg_domains_node_access($node, $op, $account) {
  $domain = domain_get_domain();

  if ($op == 'view' && user_access('clone node')) {
    return NODE_ACCESS_ALLOW;
  }
  elseif (in_array($op, array('update', 'delete')) && !isset($node->domains[$domain['domain_id']])) {
    return NODE_ACCESS_DENY;
  }

  // Allow access to the 403 and 404 pages from all domains.
  if ($op == 'view' && in_array('node/' . $node->nid, array(variable_get('site_403'), variable_get('site_404')))) {
    return NODE_ACCESS_ALLOW;
  }
  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_clone_access_alter().
 *
 * Deny clone access when the source is on the same domain.
 */
function dvg_domains_clone_access_alter(&$access, $node) {
  global $user;
  $domain = domain_get_domain();

  if (isset($node->domains[$domain['domain_id']]) && !_guardian_account_is_root($user)) {
    $access = FALSE;
  }
}

/**
 * Implements hook_clone_node_alter().
 *
 * Restore the original node title.
 */
function dvg_domains_clone_node_alter(&$node, $context) {
  $node->title = $context['original_node']->title;

  // Set the current domain as new domain.
  $current_domain = domain_get_domain();
  $node->domains = array($current_domain['domain_id'] => $current_domain['domain_id']);

  // Unpublish the clone.
  $node->status = NODE_NOT_PUBLISHED;

  _dvg_domains_clone_node_empty_fields('node', $node);
}

/**
 * Clears entity references, file and image fields.
 *
 * Removes inline media-tags from text_long-fields.
 */
function _dvg_domains_clone_node_empty_fields($entity_type, $entity) {
  $entity_wrapper = entity_metadata_wrapper($entity_type, $entity);
  $fields = field_info_fields();
  foreach ($fields as $field) {
    $field_name = $field['field_name'];
    if (!empty($entity->$field_name)) {
      switch ($field['type']) {
        case 'entityreference':
        case 'file':
        case 'image':
          $entity->$field_name = array();
          break;

        case 'field_collection':
          $fc_values = $entity_wrapper->{$field_name}->value();
          foreach ($fc_values as $fc_value) {
            _dvg_domains_clone_node_empty_fields('field_collection', $fc_value);
          }
          break;

        case 'text_long':
        case 'text_with_summary':
          // Replace inline media-tags in the field values.
          $langcode = field_language($entity_type, $entity, $field_name);
          if (empty($langcode)) {
            $langcode = LANGUAGE_NONE;
          }

          foreach ($entity->{$field_name}[$langcode] as $key => $value) {
            if (isset($value['value'])) {
              $entity->{$field_name}[$langcode][$key]['value'] = preg_replace('/\[\[\{.*?"fid":.+?\}\]\]/i', '', $value['value']);
            }
          }
          break;
      }
    }
  }
}

/**
 * Implements hook_node_view().
 */
function dvg_domains_node_view($node, $view_mode, $langcode) {
  $domain = domain_get_domain();

  if ($view_mode == 'full' && user_access('clone node') && !isset($node->domains[$domain['domain_id']]) && arg(1) == $node->nid) {
    $current_domain_id = reset($node->domains);
    $current_domain = domain_load($current_domain_id);

    $message = t('This content is published on %domain.', array('%domain' => $current_domain['sitename']));
    if (clone_access_cloning($node)) {
      $message .= ' ' . t('To clone this content to %domain use %clone.', array(
        '%domain' => $domain['sitename'],
        '%clone' => clone_action_link_title($node),
      ));
    }
    drupal_set_message($message);
  }
}

/**
 * Implements hook_query_TAG_alter().
 */
function dvg_domains_query_pathauto_bulk_update_alter(QueryAlterableInterface $query) {
  if ($query->getMetaData('entity') == 'node') {
    $domain = domain_get_domain();
    $query->leftJoin('domain_access', 'da', 'da.nid = n.nid');
    $query->condition('da.gid', $domain['domain_id']);
  }
}

/**
 * Implements hook_node_validate().
 */
function dvg_domains_node_validate($node, $form, &$form_state) {
  if (!empty($form_state['values']['domains']) && !is_array($form_state['values']['domains'])) {
    $form_state['values']['domains'] = drupal_map_assoc(array($form_state['values']['domains']));
  }
}

/**
 * Implements hook_form_alter().
 */
function dvg_domains_form_alter(&$form, &$form_state, $form_id) {
  $admin_role = user_role_load_by_name('administrator');
  $user_is_admin = user_has_role($admin_role->rid);

  // Change the way Domain Specific Settings Form
  // is displayed for non-admin users.
  if (!$user_is_admin && isset($form['domain_settings']) && user_access('access domain settings form')) {
    $replaced_default_text = _dvg_global_remove_session_message(t('This form is domain-sensitive, be sure you select the proper domain before saving.'), 'warning');

    if ($replaced_default_text) {
      $domain = domain_get_domain();

      drupal_set_message(t('This form is domain-sensitive and works only for the current domain: %url', array(
        '%url' => $domain['subdomain'],
      )), 'warning', FALSE);
    }

    $form['domain_settings']['#access'] = FALSE;
  }
}

/**
 * Implements hook_domain_load().
 */
function dvg_domains_domain_load(&$domain) {
  global $_domain;

  // There's no alias is active, so nothing to do here.
  if (empty($_domain['active_alias_id'])) {
    return;
  }

  // If editing domains, don't change anything.
  if (strpos(current_path(), 'admin/structure/domain') !== FALSE) {
    return;
  }

  // Make sure we have aliases loaded.
  if (empty($_domain['aliases'])) {
    $_domain['aliases'] = domain_alias_list($_domain['domain_id']);
  }
  if (empty($domain['aliases'])) {
    $domain['aliases'] = domain_alias_list($domain['domain_id']);
  }

  // Cross match aliases by index-number of the alias-id.
  $_alias_keys = array_keys($_domain['aliases']);
  $_index = array_search($_domain['active_alias_id'], $_alias_keys);
  $_alias = $_domain['aliases'][$_domain['active_alias_id']];
  $alias_keys = array_keys($domain['aliases']);

  if (!isset($alias_keys[$_index])) {
    return;
  }

  $key = $alias_keys[$_index];

  // Build a good url/path for the domain alias.
  $alias = $domain['aliases'][$key];
  $alias_path = $alias['pattern'];
  if (strpos($alias_path, '*') !== FALSE) {
    // Find the wildcard replacements in the current base url
    // using the current active
    // alias, and put them on the wildcard for the loaded domain.
    $replacements = array(
      '.' => '\.',
      '*' => '(.+?)',
    );
    $regex = '/^' . strtr($_alias['pattern'], $replacements) . '$/';
    $matches = array();
    if (preg_match($regex, domain_request_name(), $matches)) {
      $alias_path = str_replace('*', $matches[1], $alias_path);
    }
  }

  $domain['subdomain'] = $alias_path;
  $domain['path'] = domain_check_scheme($domain['scheme']) . '://' . $alias_path;
}


/**
 * Implements hook_domain_batch().
 */
function dvg_domains_domain_batch() {
  // Make the 403 and 404 pages domain specific
  // and editable from the domain settings page.
  $batch = array();

  // Change the site 403 page.
  $batch['site_403'] = array(
    '#form' => array(
      '#title' => t('Default 403 (access denied) page'),
      '#type' => 'textfield',
      '#size' => 40,
      '#maxlength' => 255,
      '#description' => t('This page is displayed when the requested document is denied to the current user. Leave blank to display a generic "access denied" page.'),
    ),
    '#permission' => 'administer site configuration',
    '#domain_action' => 'domain_conf',
    '#system_default' => variable_get('site_403', ''),
    '#variable' => 'site_403',
    '#meta_description' => t('Set the 403 (access denied) page for all domains.'),
    '#data_type' => 'string',
    '#weight' => 0,
    '#update_all' => TRUE,
    '#group' => t('Error pages'),
  );
  // Change the site 404 page.
  $batch['site_404'] = array(
    '#form' => array(
      '#title' => t('Default 404 (not found) page'),
      '#type' => 'textfield',
      '#size' => 40,
      '#maxlength' => 255,
      '#description' => t('This page is displayed when no other content matches the requested document. Leave blank to display a generic "page not found" page.'),
    ),
    '#permission' => 'administer site configuration',
    '#domain_action' => 'domain_conf',
    '#system_default' => variable_get('site_404', ''),
    '#variable' => 'site_404',
    '#meta_description' => t('Set the 404 (not found) page for all domains.'),
    '#data_type' => 'string',
    '#weight' => 0,
    '#update_all' => TRUE,
    '#group' => t('Error pages'),
  );
  return $batch;
}

/**
 * Implements hook_entity_property_info_alter().
 *
 * Adds an entity property for the domain access of the node.
 */
function dvg_domains_entity_property_info_alter(&$info) {
  foreach ($info as &$entity_type) {
    $properties = &$entity_type['properties'];

    $properties['custom_domain_access'] = array(
      'label' => t('Domain Access Information'),
      'description' => t('The domains to which the node is published.'),
      'type' => 'list<integer>',
      'getter callback' => 'dvg_domains_get_domain_info',
    );
  }
}

/**
 * Search-index getter callback that returns the selected domains.
 */
function dvg_domains_get_domain_info($data, array $options, $name, $type, $info) {
  $domains = array();
  // Published to all domains.
  if ($data->domain_site) {
    $domains[] = 0;
  }
  if (!empty($data->domains)) {
    $domains = $data->domains;
  }

  return (!empty($domains) ? $domains : NULL);
}

/**
 * Implements hook_search_api_query_alter().
 *
 * Adds a filter for the current domain or all domains.
 */
function dvg_domains_search_api_query_alter(SearchApiQueryInterface $query) {
  $dvg_domains_search_current_domain_only = variable_get('dvg_domains_search_current_domain_only', 1);
  if ($dvg_domains_search_current_domain_only) {
    $domain = domain_get_domain();
    $filter = $query->createFilter('OR');
    $filter->condition('custom_domain_access', 0);
    $filter->condition('custom_domain_access', $domain['domain_id']);
    $query->filter($filter);
  }
}

/**
 * Implements hook_preprocess_page().
 */
function dvg_domains_preprocess_page(&$variables) {
  $type = drupal_installation_attempted() ? 'warning' : 'error';
  $message = t('Domain module installation is incomplete. See INSTALL.txt and check your settings.php file.');
  $domain_message_exists = FALSE;
  if (isset($_SESSION['messages'][$type])) {
    foreach ($_SESSION['messages'][$type] as $key => $value) {
      if ($message == $value) {
        $_SESSION['messages'][$type][$key] = t('DVG Domain module installation is incomplete. Add the following to the settings.php file: <pre>@code</pre>', array('@code' => "include DRUPAL_ROOT . '/profiles/dvg/modules/contrib/domain/settings.inc';"));
        $domain_message_exists = TRUE;
      }
    }
  }
  if ($domain_message_exists) {
    $type = 'error';
    $message = t('Domain access failed to load during phase: bootstrap include. Please check your settings.php file and site configuration.');
    if (isset($_SESSION['messages'][$type])) {
      foreach ($_SESSION['messages'][$type] as $key => $value) {
        if ($message == $value) {
          unset($_SESSION['messages'][$type][$key]);
        }
      }
    }
  }

}

/**
 * Implements hook_redirect_load_by_source_alter().
 */
function dvg_domains_redirect_load_by_source_alter(array &$redirects, $source, array $context) {
  global $_domain;
  $current_domain_id = $_domain['domain_id'];

  // The redirect module only checks on the url alias of a node. It does not
  // check if the redirect is for a node on the current domain. So we need to do
  // this check manually.
  foreach ($redirects as $key => $redirect) {
    // Check if the target of the redirect is a node.
    $nid_position = strpos($redirect->redirect, 'node/');
    if ($nid_position === FALSE) {
      continue;
    }
    $nid = substr($redirect->redirect, $nid_position + 5);
    $node = node_load($nid);

    if ($node->domain_site) {
      // The node is available on all domains.
      continue;
    }

    if (!in_array($current_domain_id, $node->domains)) {
      // The node is unavailable on the current domain.
      unset($redirects[$key]);
    }
  }
}
